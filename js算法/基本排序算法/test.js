基本排序---冒泡排序<选择排序<插入排序， 

// 我们先来了解一下冒泡排序算法，它是最慢的排序算法之一，但也是一种最容易实现的排 序算法。
// 之所以叫冒泡排序是因为使用这种排序算法排序时，
// 数据值会像气泡一样从数组的一端漂 浮到另一端。
// 假设正在将一组数字按照升序排列，较大的值会浮动到数组的右侧，
// 而较小 的值则会浮动到数组的左侧。之所以会产生这种现象是因为算法会多次在数组中移动，
// 比 较相邻的数据，当左侧值大于右侧值时将它们进行互换


// 我们接下来要看的是选择排序算法。
// 选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。
// 检查完所有元素后，最小的元素会被放到数组的第一个位置，
// 然后算法会从 第二个位置继续。这个过程一直进行，
// 当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。
// 选择排序会用到嵌套循环。外循环从数组的第一个元素移动到倒数第二个元素；
// 内循环从第 二个数组元素移动到最后一个元素，查找比当前外循环所指向的元素小的元素。
// 每次内循环 迭代后，数组中最小的值都会被赋值到合适的位置。


// 插入排序类似于人类按数字或字母顺序对数据进行排序。例如，
// 让班里的每个学生上交一 张写有他的名字、学生证号以及个人简介的索引卡片。
// 学生交上来的卡片是没有顺序的， 但是我想让这些卡片按字母顺序排好，
// 这样就可以很容易地与班级花名册进行对照了。
// 我将卡片带回办公室，清理好书桌，然后拿起第一张卡片。卡片上的姓氏是 Smith。
// 我把 它放到桌子的左上角，然后再拿起第二张卡片。
// 这张卡片上的姓氏是 Brown。我把 Smith 移右，把 Brown 放到 Smith 的前面。
// 下一张卡片是 Williams，可以把它放到桌面最右边， 而不用移动其他任何卡片。
// 下一张卡片是 Acklin。这张卡片必须放在这些卡片的最前面， 
// 因此其他所有卡片必须向右移动一个位置来为 Acklin 这张卡片腾出位置。
// 这就是插入排序 的排序原理。
// 插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 
// 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，
// 那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。

// 选择排序和插入排序要比冒泡 排序快，插入排序是这三种算法中最快的。

高级排序---快速排序、希尔排序、归并排序和堆排序。

// 归并排序的命名来自它的实现原理：把一系列排好序的子序列合并成一个大的完整有序序 列。
// 从理论上讲，这个算法很容易实现。我们需要两个排好序的子数组，
// 然后通过比较数 据大小，先从最小的数据开始插入，最后合并得到第三个数组。
// 然而，在实际情况中，归 并排序还有一些问题，当我们用这个算法对一个很大的数据集进行排序时
// ，我们需要相当 大的空间来合并存储两个子数组。就现在来讲，内存不那么昂贵，空间不是问题，
// 因此值 得我们去实现一下归并排序，比较它和其他排序算法的执行效率。


// 首先要学习的第一个高级排序算法是希尔排序。希尔排序是以它的创造者（Donald Shell） 命名的。
// 这个算法在插入排序的基础上做了很大的改善。希尔排序的核心理念与插入排序 不同，
// 它会首先比较距离较远的元素，而非相邻的元素。和简单地比较相邻元素相比，
// 使 用这种方案可以使离正确位置很远的元素更快地回到合适的位置。
// 当开始用这个算法遍历 数据集时，所有元素之间的距离会不断减小，直到处理到数据集的末尾，
// 这时算法比较的 就是相邻元素了。
// 希尔排序的工作原理是，通过定义一个间隔序列来表示在排序过程中进行比较的元素之 间有多远的间隔。
// 我们可以动态定义间隔序列，不过对于大部分的实际应用场景，
// 算法 要用到的间隔序列可以提前定义好。有一些公开定义的间隔序列，使用它们会得到不同 的结果。


// 快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，
// 通过递归的方 式将数据依次分解为包含较小元素和较大元素的不同子序列。
// 该算法不断重复这个步骤直 到所有数据都是有序的。
// 这个算法首先要在列表中选择一个元素作为基准值（pivot）。
// 数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，
// 将大于基准值的元素移到数组的顶部。
